# 对于操作的实现代码

## 例一：创建画布

由于创建这一操作会被提升至开头，所以直接把display改为block

```ts
const sprite = sprites[name];
sprite.style.dispaly = 'block';
```

## 例二：绘制线段

```ts
const sprite = sprites[name];
core.drawLine(sprite, data.x1, data.y1, data.x2, data.y2, data.color, data.lineWidth)
```

## 例三：绘制贝塞尔曲线

```ts
const sprite = sprites[name];
const ctx = sprite.context;
ctx.moveTo(data.sx, data.sy);
ctx.bezierCurveTo(data.cp1x, data.cp1y, data.cp2x, data.cp2y, data.x, data.y);
ctx.fillStyle = data.color;
ctx.strokeStyle = data.color;
ctx.lineWidth = data.lineWidth;
ctx.stroke();
```

# 编译成js代码

样板只能用es5，所以只能编译成es5代码

示例：

```actions
创建画布
    name: test
    x: 0
    y: 0
    w: 200
    h: 200
    z: 150
等待
    time: 1000
设置过渡
    sprite: test
    style: left
    time: 0.2s
    mode: ease-out
    delay: 0
移动画布
    sprite: test
    x: 200
    y: 0
    isDelta: false
绘制直线
    sprite: test
    x1: 0
    y1: 0
    x2: 100
    y2: 100
    color: red
    lineWidth: 2
等待
    time: 200
设置css
    sprite: test
    data: box-shadow: 0px 0px 2px #000;
等待
    time: 5000
删除画布
    sprite: test
```

编译结果，注释不在编译结果内，此处注释只是为了方便理解编译结果

```js
// list为各项操作的信息
var test = new Sprite(0, 0, 200, 200, 150, 'game', 'test');
var testCtx = test.context;
test.setCss('display: none;'); // 创建画布提升至开头，所以每次创建后需要隐藏
test.setCss('display: block;'); // 执行到create这个操作时，把指定画布显示并清空
core.clearMap(testCtx);
// ---- 第一步完毕
// 遇到等待，将等待作为分割点，中间的区域作为单独的函数
setTimeout(action_2_4, 1000);
function action_2_4 () {
    // 开始第三步至第五步
    test.canvas.style.transition += ', left 0.2s 0 ease-out';
    // 修改过渡以后不会立刻生效，这里延迟50ms再进行之后的操作
    setTimeout(function () {
        test.move(200, 0, false);
        core.drawLine(testCtx, 0, 0, 100, 100, 'red', 2);
        setTimeout(action_6_6, 200);
    }, 50);
}
function action_6_6 () {
    test.setCss('box-shadow: 0px 0px 2px #000;');
    setTimeout(action_8_8, 5000);
}
function action_8_8 () {
    test.setCss('display: none'); // 为了防止之后再次创建同名画布
    finish();
}

function finish () {
    // 结束函数，把所有的已被“删除”的画布删除
    test.destroy();
}
```